<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agent Simulation v2 | BlackRoad Pixel Metaverse</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0a;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      color: #fff;
    }
    #canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 2px solid #FF1D6C;
    }
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.9);
      padding: 15px;
      border: 2px solid #F5A623;
      border-radius: 4px;
      font-size: 11px;
      min-width: 280px;
    }
    .stat { margin: 5px 0; color: #2979FF; }
    .stat strong { color: #FF1D6C; }
    #agent-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.95);
      padding: 15px;
      border: 2px solid #9C27B0;
      border-radius: 4px;
      width: 320px;
      font-size: 11px;
      display: none;
      max-height: 90vh;
      overflow-y: auto;
    }
    #agent-panel.active { display: block; }
    .need-bar {
      margin: 8px 0;
    }
    .need-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
      font-size: 10px;
    }
    .bar-container {
      width: 100%;
      height: 12px;
      background: #222;
      border: 1px solid #444;
      border-radius: 2px;
      overflow: hidden;
    }
    .bar-fill {
      height: 100%;
      transition: width 0.3s ease;
    }
    .hunger-bar { background: linear-gradient(90deg, #F5A623, #FF6B35); }
    .energy-bar { background: linear-gradient(90deg, #2979FF, #4ECDC4); }
    .mood-bar { background: linear-gradient(90deg, #52FF52, #FFD700); }
    .social-bar { background: linear-gradient(90deg, #FF1D6C, #9C27B0); }
    .hygiene-bar { background: linear-gradient(90deg, #4ECDC4, #52FF52); }
    
    .need-critical { animation: pulse 1s infinite; }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    #event-log {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      padding: 10px;
      border: 2px solid #9C27B0;
      border-radius: 4px;
      width: 320px;
      height: 150px;
      overflow-y: auto;
      font-size: 10px;
    }
    .event { margin: 3px 0; opacity: 0.9; }
    .event-need { color: #F5A623; }
    .event-action { color: #52FF52; }
    .event-social { color: #FF1D6C; }
    .event-mood { color: #FFD700; }
    .event-memory { color: #9C27B0; }
    
    h1 { color: #FF1D6C; margin-bottom: 10px; font-size: 14px; }
    h2 { color: #F5A623; margin-bottom: 8px; font-size: 12px; }
    h3 { color: #2979FF; margin-top: 10px; margin-bottom: 5px; font-size: 11px; }
    
    .action-queue {
      margin-top: 10px;
      padding: 8px;
      background: rgba(255, 29, 108, 0.1);
      border-radius: 3px;
      font-size: 10px;
    }
    .action-item {
      margin: 3px 0;
      color: #4ECDC4;
    }
    
    .personality-traits {
      margin-top: 10px;
      padding: 8px;
      background: rgba(41, 121, 255, 0.1);
      border-radius: 3px;
      font-size: 10px;
    }
    .trait {
      display: inline-block;
      margin: 2px;
      padding: 2px 6px;
      background: rgba(255, 29, 108, 0.3);
      border-radius: 3px;
      font-size: 9px;
    }
    
    .memory-section {
      margin-top: 10px;
      padding: 8px;
      background: rgba(156, 39, 176, 0.1);
      border-radius: 3px;
      font-size: 10px;
      max-height: 150px;
      overflow-y: auto;
    }
    .memory-item {
      margin: 3px 0;
      color: #9C27B0;
      font-size: 9px;
    }
    
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.9);
      padding: 10px;
      border: 2px solid #2979FF;
      border-radius: 4px;
    }
    button {
      background: #FF1D6C;
      color: white;
      border: none;
      padding: 8px 12px;
      margin: 3px;
      border-radius: 3px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 10px;
    }
    button:hover { background: #F5A623; }
    button:active { transform: scale(0.95); }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="hud">
    <h1>üß† AGENT SIMULATION v2</h1>
    <div class="stat">Agents: <strong id="agent-count">0</strong></div>
    <div class="stat">Time: <strong id="game-time">00:00</strong></div>
    <div class="stat">Speed: <strong id="game-speed">1x</strong></div>
    <div class="stat">FPS: <strong id="fps">60</strong></div>
    <div class="stat" style="color: #52FF52;">‚ö° A* Pathfinding Active</div>
    <div class="stat" style="color: #4ECDC4;">üß† Collision Detection On</div>
  </div>

  <div id="agent-panel">
    <h2>Agent: <span id="agent-name">None</span></h2>
    
    <div class="personality-traits">
      <strong>üé≠ Personality:</strong>
      <div id="traits-list"></div>
    </div>
    
    <h3>üìä Needs</h3>
    <div class="need-bar">
      <div class="need-label">
        <span>üçî Hunger</span>
        <span id="hunger-value">100%</span>
      </div>
      <div class="bar-container">
        <div class="bar-fill hunger-bar" id="hunger-bar" style="width: 100%"></div>
      </div>
    </div>
    <div class="need-bar">
      <div class="need-label">
        <span>‚ö° Energy</span>
        <span id="energy-value">100%</span>
      </div>
      <div class="bar-container">
        <div class="bar-fill energy-bar" id="energy-bar" style="width: 100%"></div>
      </div>
    </div>
    <div class="need-bar">
      <div class="need-label">
        <span>üòä Mood</span>
        <span id="mood-value">100%</span>
      </div>
      <div class="bar-container">
        <div class="bar-fill mood-bar" id="mood-bar" style="width: 100%"></div>
      </div>
    </div>
    <div class="need-bar">
      <div class="need-label">
        <span>üë• Social</span>
        <span id="social-value">100%</span>
      </div>
      <div class="bar-container">
        <div class="bar-fill social-bar" id="social-bar" style="width: 100%"></div>
      </div>
    </div>
    <div class="need-bar">
      <div class="need-label">
        <span>üöø Hygiene</span>
        <span id="hygiene-value">100%</span>
      </div>
      <div class="bar-container">
        <div class="bar-fill hygiene-bar" id="hygiene-bar" style="width: 100%"></div>
      </div>
    </div>
    
    <div class="action-queue">
      <strong>üéØ Current Action:</strong>
      <div id="action-list"></div>
    </div>
    
    <div class="memory-section">
      <strong>üí≠ Memories (<span id="memory-count">0</span>):</strong>
      <div id="memory-list"></div>
    </div>
  </div>

  <div id="event-log"></div>

  <div id="controls">
    <button onclick="addAgent()">+ Add Agent</button>
    <button onclick="toggleSpeed()">‚è© Speed</button>
    <button onclick="pauseGame()">‚è∏ Pause</button>
    <button onclick="showDebug()">üêõ Debug Path</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    const PIXEL_SIZE = 8;
    const GRID_SIZE = 50; // For A* pathfinding
    let debugPath = false;
    
    // Agent sprite
    const AGENT_SPRITE = [
      '  ‚ñà‚ñà‚ñà‚ñà  ',
      ' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      ' ‚ñà‚ñà  ‚ñà‚ñà ',
      ' ‚ñà‚ñà  ‚ñà‚ñà ',
      '        '
    ];

    const FRIDGE_SPRITE = [
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà',
      '‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà',
      '‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà',
      '‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'
    ];

    const BED_SPRITE = [
      '            ',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '            '
    ];

    const COUCH_SPRITE = [
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'
    ];

    const SHOWER_SPRITE = [
      '  ‚ñà‚ñà‚ñà‚ñà  ',
      '  ‚ñà‚ñà‚ñà‚ñà  ',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
      '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'
    ];

    function drawSprite(sprite, x, y, color = '#FF1D6C') {
      ctx.fillStyle = color;
      sprite.forEach((row, rowIndex) => {
        for (let col = 0; col < row.length; col++) {
          const char = row[col];
          if (char === '‚ñà') {
            ctx.fillRect(x + col * PIXEL_SIZE, y + rowIndex * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
          } else if (char === '‚ñë') {
            ctx.fillStyle = '#333';
            ctx.fillRect(x + col * PIXEL_SIZE, y + rowIndex * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            ctx.fillStyle = color;
          }
        }
      });
    }

    // Game state
    let gameTime = 0;
    let gameSpeed = 1;
    let paused = false;
    let selectedAgent = null;

    // Furniture/objects
    const furniture = [
      { type: 'fridge', x: 100, y: 100, sprite: FRIDGE_SPRITE, action: 'eat', width: 64, height: 64 },
      { type: 'bed', x: 300, y: 100, sprite: BED_SPRITE, action: 'sleep', width: 96, height: 48 },
      { type: 'couch', x: 500, y: 100, sprite: COUCH_SPRITE, action: 'socialize', width: 96, height: 40 },
      { type: 'shower', x: 700, y: 100, sprite: SHOWER_SPRITE, action: 'shower', width: 64, height: 64 },
      { type: 'fridge', x: 100, y: 400, sprite: FRIDGE_SPRITE, action: 'eat', width: 64, height: 64 },
      { type: 'bed', x: 300, y: 400, sprite: BED_SPRITE, action: 'sleep', width: 96, height: 48 },
      { type: 'couch', x: 500, y: 400, sprite: COUCH_SPRITE, action: 'socialize', width: 96, height: 40 },
      { type: 'shower', x: 700, y: 400, sprite: SHOWER_SPRITE, action: 'shower', width: 64, height: 64 }
    ];

    // Personality traits
    const TRAITS = {
      friendly: { emoji: 'üòä', decayModifier: { social: 1.2 } },
      shy: { emoji: 'üò≥', decayModifier: { social: 0.7 } },
      energetic: { emoji: '‚ö°', decayModifier: { energy: 0.8 } },
      lazy: { emoji: 'üò¥', decayModifier: { energy: 1.3 } },
      neat: { emoji: '‚ú®', decayModifier: { hygiene: 0.7 } },
      messy: { emoji: 'üå™Ô∏è', decayModifier: { hygiene: 1.4 } },
      foodie: { emoji: 'üçï', decayModifier: { hunger: 1.2 } },
      efficient: { emoji: 'üéØ', decayModifier: {} }
    };

    // A* Pathfinding
    class AStarPathfinder {
      constructor(gridWidth, gridHeight, gridSize) {
        this.gridWidth = Math.floor(gridWidth / gridSize);
        this.gridHeight = Math.floor(gridHeight / gridSize);
        this.gridSize = gridSize;
      }

      heuristic(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
      }

      getNeighbors(node) {
        const neighbors = [];
        const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];
        
        dirs.forEach(([dx, dy]) => {
          const x = node.x + dx;
          const y = node.y + dy;
          if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
            neighbors.push({ x, y });
          }
        });
        
        return neighbors;
      }

      findPath(start, goal, obstacles) {
        const startNode = {
          x: Math.floor(start.x / this.gridSize),
          y: Math.floor(start.y / this.gridSize)
        };
        const goalNode = {
          x: Math.floor(goal.x / this.gridSize),
          y: Math.floor(goal.y / this.gridSize)
        };

        const openSet = [startNode];
        const cameFrom = new Map();
        const gScore = new Map();
        const fScore = new Map();
        
        const key = (node) => `${node.x},${node.y}`;
        
        gScore.set(key(startNode), 0);
        fScore.set(key(startNode), this.heuristic(startNode, goalNode));

        while (openSet.length > 0) {
          openSet.sort((a, b) => (fScore.get(key(a)) || Infinity) - (fScore.get(key(b)) || Infinity));
          const current = openSet.shift();

          if (current.x === goalNode.x && current.y === goalNode.y) {
            // Reconstruct path
            const path = [current];
            let temp = current;
            while (cameFrom.has(key(temp))) {
              temp = cameFrom.get(key(temp));
              path.unshift(temp);
            }
            return path.map(node => ({
              x: node.x * this.gridSize + this.gridSize / 2,
              y: node.y * this.gridSize + this.gridSize / 2
            }));
          }

          const neighbors = this.getNeighbors(current);
          neighbors.forEach(neighbor => {
            // Check if blocked by obstacle
            const blocked = obstacles.some(obs => {
              const obsGridX = Math.floor(obs.x / this.gridSize);
              const obsGridY = Math.floor(obs.y / this.gridSize);
              return neighbor.x === obsGridX && neighbor.y === obsGridY;
            });

            if (blocked) return;

            const tentativeGScore = (gScore.get(key(current)) || Infinity) + 1;
            
            if (tentativeGScore < (gScore.get(key(neighbor)) || Infinity)) {
              cameFrom.set(key(neighbor), current);
              gScore.set(key(neighbor), tentativeGScore);
              fScore.set(key(neighbor), tentativeGScore + this.heuristic(neighbor, goalNode));
              
              if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                openSet.push(neighbor);
              }
            }
          });
        }

        return null; // No path found
      }
    }

    const pathfinder = new AStarPathfinder(canvas.width, canvas.height, GRID_SIZE);

    // Agent AI class with personality and memory
    class SimAgent {
      constructor(id, name, color) {
        this.id = id;
        this.name = name;
        this.color = color;
        this.x = Math.random() * (canvas.width - 200) + 100;
        this.y = Math.random() * (canvas.height - 200) + 100;
        this.size = 64;
        
        // Personality traits (random 2-3 traits)
        this.traits = this.generateTraits();
        
        // Needs (0-100)
        this.hunger = 100;
        this.energy = 100;
        this.mood = 100;
        this.social = 100;
        this.hygiene = 100;
        
        // AI state
        this.currentAction = null;
        this.target = null;
        this.actionProgress = 0;
        this.path = null;
        this.pathIndex = 0;
        
        // Movement
        this.vx = 0;
        this.vy = 0;
        this.speed = 2;
        
        // Memory system
        this.memories = [];
        this.relationships = new Map(); // Agent ID -> relationship value
      }

      generateTraits() {
        const traitKeys = Object.keys(TRAITS);
        const numTraits = Math.floor(Math.random() * 2) + 2; // 2-3 traits
        const selected = [];
        
        for (let i = 0; i < numTraits && traitKeys.length > 0; i++) {
          const index = Math.floor(Math.random() * traitKeys.length);
          selected.push(traitKeys[index]);
          traitKeys.splice(index, 1);
        }
        
        return selected;
      }

      getTraitModifier(need) {
        let modifier = 1.0;
        this.traits.forEach(trait => {
          if (TRAITS[trait].decayModifier[need]) {
            modifier *= TRAITS[trait].decayModifier[need];
          }
        });
        return modifier;
      }

      addMemory(text, type = 'general') {
        const memory = {
          text,
          type,
          timestamp: gameTime,
          timeString: new Date().toLocaleTimeString()
        };
        this.memories.unshift(memory);
        if (this.memories.length > 20) this.memories.pop();
        
        logEvent(`${this.name} remembers: ${text}`, 'memory');
      }

      decayNeeds(deltaTime) {
        const factor = deltaTime * gameSpeed;
        this.hunger = Math.max(0, this.hunger - 0.02 * factor * this.getTraitModifier('hunger'));
        this.energy = Math.max(0, this.energy - 0.015 * factor * this.getTraitModifier('energy'));
        this.mood = Math.max(0, this.mood - 0.01 * factor);
        this.social = Math.max(0, this.social - 0.008 * factor * this.getTraitModifier('social'));
        this.hygiene = Math.max(0, this.hygiene - 0.012 * factor * this.getTraitModifier('hygiene'));
        
        if (this.hunger < 30 || this.energy < 30 || this.hygiene < 30) {
          this.mood = Math.max(0, this.mood - 0.02 * factor);
        }
      }

      makeDecision() {
        if (this.currentAction) return;
        
        const needs = [
          { name: 'hunger', value: this.hunger, action: 'eat', critical: 20 },
          { name: 'energy', value: this.energy, action: 'sleep', critical: 25 },
          { name: 'hygiene', value: this.hygiene, action: 'shower', critical: 30 },
          { name: 'social', value: this.social, action: 'socialize', critical: 35 },
        ];
        
        needs.sort((a, b) => a.value - b.value);
        const mostCritical = needs[0];
        
        if (mostCritical.value < mostCritical.critical) {
          this.startAction(mostCritical.action);
          this.addMemory(`Feeling ${mostCritical.name} is low`, 'need');
        }
      }

      startAction(action) {
        const validFurniture = furniture.filter(f => f.action === action);
        if (validFurniture.length === 0) return;
        
        let nearest = validFurniture[0];
        let minDist = Infinity;
        
        validFurniture.forEach(f => {
          const dist = Math.hypot(f.x - this.x, f.y - this.y);
          if (dist < minDist) {
            minDist = dist;
            nearest = f;
          }
        });
        
        this.currentAction = action;
        this.target = nearest;
        this.actionProgress = 0;
        
        // Calculate A* path
        this.path = pathfinder.findPath(
          { x: this.x, y: this.y },
          { x: nearest.x, y: nearest.y },
          furniture.filter(f => f !== nearest)
        );
        this.pathIndex = 0;
        
        logEvent(`${this.name} pathfinding to ${action}`, 'action');
        this.addMemory(`Going to ${action}`, 'action');
      }

      checkCollision(other) {
        if (other === this) return false;
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const dist = Math.hypot(dx, dy);
        return dist < (this.size + other.size) / 2;
      }

      resolveCollision(other) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist === 0) return;
        
        const overlap = ((this.size + other.size) / 2) - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        
        this.x += nx * overlap * 0.5;
        this.y += ny * overlap * 0.5;
        other.x -= nx * overlap * 0.5;
        other.y -= ny * overlap * 0.5;
        
        // Social interaction on collision
        if (Math.random() < 0.01) {
          const currentRel = this.relationships.get(other.id) || 0;
          this.relationships.set(other.id, Math.min(100, currentRel + 5));
          
          this.addMemory(`Met ${other.name}`, 'social');
          this.social = Math.min(100, this.social + 2);
        }
      }

      update() {
        if (paused) return;
        
        this.decayNeeds(1);
        
        if (this.currentAction && this.target) {
          if (this.path && this.pathIndex < this.path.length) {
            // Follow A* path
            const waypoint = this.path[this.pathIndex];
            const dx = waypoint.x - this.x;
            const dy = waypoint.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist < 10) {
              this.pathIndex++;
            } else {
              this.vx = (dx / dist) * this.speed * gameSpeed;
              this.vy = (dy / dist) * this.speed * gameSpeed;
              this.x += this.vx;
              this.y += this.vy;
            }
          } else {
            // At target
            this.vx = 0;
            this.vy = 0;
            this.actionProgress += gameSpeed;
            
            if (this.actionProgress >= 120) {
              this.completeAction();
            }
          }
        } else {
          this.makeDecision();
          
          if (!this.currentAction) {
            this.x += this.vx;
            this.y += this.vy;
            
            if (Math.random() < 0.02) {
              this.vx = (Math.random() - 0.5) * 1 * gameSpeed;
              this.vy = (Math.random() - 0.5) * 1 * gameSpeed;
            }
            
            if (this.x < 50 || this.x > canvas.width - 100) this.vx *= -1;
            if (this.y < 50 || this.y > canvas.height - 100) this.vy *= -1;
          }
        }
        
        // Keep in bounds
        this.x = Math.max(50, Math.min(canvas.width - 100, this.x));
        this.y = Math.max(50, Math.min(canvas.height - 100, this.y));
      }

      completeAction() {
        const amount = 40;
        
        switch(this.currentAction) {
          case 'eat':
            this.hunger = Math.min(100, this.hunger + amount);
            this.mood = Math.min(100, this.mood + 10);
            this.addMemory('Had a delicious meal!', 'action');
            break;
          case 'sleep':
            this.energy = Math.min(100, this.energy + amount);
            this.mood = Math.min(100, this.mood + 10);
            this.addMemory('Took a refreshing nap', 'action');
            break;
          case 'shower':
            this.hygiene = Math.min(100, this.hygiene + amount);
            this.mood = Math.min(100, this.mood + 10);
            this.addMemory('Feeling clean and fresh', 'action');
            break;
          case 'socialize':
            this.social = Math.min(100, this.social + amount);
            this.mood = Math.min(100, this.mood + 15);
            this.addMemory('Had a great conversation', 'social');
            break;
        }
        
        logEvent(`${this.name} completed ${this.currentAction}!`, 'action');
        this.currentAction = null;
        this.target = null;
        this.path = null;
        this.actionProgress = 0;
      }

      draw() {
        drawSprite(AGENT_SPRITE, this.x, this.y, this.color);
        
        // Name tag
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(this.x - 5, this.y - 20, 70, 15);
        ctx.fillStyle = this.color;
        ctx.font = '10px monospace';
        ctx.fillText(this.name, this.x, this.y - 10);
        
        // Trait emoji
        if (this.traits.length > 0) {
          ctx.font = '12px monospace';
          ctx.fillText(TRAITS[this.traits[0]].emoji, this.x - 20, this.y + 10);
        }
        
        // Action indicator
        if (this.currentAction) {
          const emoji = {
            eat: 'üçî',
            sleep: 'üí§',
            shower: 'üöø',
            socialize: 'üí¨'
          }[this.currentAction];
          
          ctx.font = '16px monospace';
          ctx.fillText(emoji, this.x + 50, this.y - 10);
          
          const progress = this.actionProgress / 120;
          ctx.fillStyle = 'rgba(255, 29, 108, 0.5)';
          ctx.fillRect(this.x, this.y + 70, 64 * progress, 4);
        }
        
        // Debug: Draw path
        if (debugPath && this.path) {
          ctx.strokeStyle = 'rgba(255, 29, 108, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.x + 32, this.y + 32);
          this.path.forEach(point => {
            ctx.lineTo(point.x, point.y);
          });
          ctx.stroke();
        }
        
        if (this.hunger < 20 || this.energy < 25 || this.hygiene < 30) {
          ctx.fillStyle = '#FF1D6C';
          ctx.font = '20px monospace';
          ctx.fillText('!', this.x + 55, this.y + 10);
        }
      }
    }

    const agents = new Map();
    const AGENT_COLORS = ['#FF1D6C', '#F5A623', '#2979FF', '#9C27B0', '#52FF52', '#4ECDC4', '#FF6B35'];
    let agentIdCounter = 0;

    function addAgent() {
      const id = `agent-${agentIdCounter++}`;
      const name = `Agent${agentIdCounter}`;
      const color = AGENT_COLORS[agents.size % AGENT_COLORS.length];
      const agent = new SimAgent(id, name, color);
      agents.set(id, agent);
      logEvent(`${name} joined with traits: ${agent.traits.join(', ')}`, 'action');
    }

    function logEvent(message, type = 'action') {
      const log = document.getElementById('event-log');
      const div = document.createElement('div');
      div.className = `event event-${type}`;
      div.textContent = `${new Date().toLocaleTimeString()} ${message}`;
      log.insertBefore(div, log.firstChild);
      if (log.children.length > 50) log.removeChild(log.lastChild);
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      let clicked = null;
      agents.forEach(agent => {
        if (clickX >= agent.x && clickX <= agent.x + 64 &&
            clickY >= agent.y && clickY <= agent.y + 64) {
          clicked = agent;
        }
      });
      
      selectedAgent = clicked;
      document.getElementById('agent-panel').classList.toggle('active', !!clicked);
      
      if (clicked) {
        updateAgentPanel(clicked);
      }
    });

    function updateAgentPanel(agent) {
      document.getElementById('agent-name').textContent = agent.name;
      
      // Traits
      const traitsList = document.getElementById('traits-list');
      traitsList.innerHTML = agent.traits.map(trait => 
        `<span class="trait">${TRAITS[trait].emoji} ${trait}</span>`
      ).join('');
      
      const updateBar = (need, value) => {
        document.getElementById(`${need}-value`).textContent = `${Math.round(value)}%`;
        document.getElementById(`${need}-bar`).style.width = `${value}%`;
        
        const barElement = document.getElementById(`${need}-bar`).parentElement.parentElement;
        if (value < 30) {
          barElement.classList.add('need-critical');
        } else {
          barElement.classList.remove('need-critical');
        }
      };
      
      updateBar('hunger', agent.hunger);
      updateBar('energy', agent.energy);
      updateBar('mood', agent.mood);
      updateBar('social', agent.social);
      updateBar('hygiene', agent.hygiene);
      
      const actionList = document.getElementById('action-list');
      if (agent.currentAction) {
        actionList.innerHTML = `<div class="action-item">‚Üí ${agent.currentAction} (${Math.round(agent.actionProgress / 120 * 100)}%)</div>`;
      } else {
        actionList.innerHTML = `<div class="action-item">‚Üí Thinking...</div>`;
      }
      
      // Memories
      document.getElementById('memory-count').textContent = agent.memories.length;
      const memoryList = document.getElementById('memory-list');
      memoryList.innerHTML = agent.memories.slice(0, 10).map(mem => 
        `<div class="memory-item">${mem.timeString} - ${mem.text}</div>`
      ).join('');
    }

    function toggleSpeed() {
      gameSpeed = gameSpeed === 1 ? 2 : gameSpeed === 2 ? 4 : 1;
      document.getElementById('game-speed').textContent = `${gameSpeed}x`;
      logEvent(`Game speed: ${gameSpeed}x`, 'action');
    }

    function pauseGame() {
      paused = !paused;
      logEvent(paused ? 'Game paused' : 'Game resumed', 'action');
    }

    function showDebug() {
      debugPath = !debugPath;
      logEvent(debugPath ? 'Path debug ON' : 'Path debug OFF', 'action');
    }

    let fps = 60;
    let lastTime = Date.now();
    let frameCount = 0;

    function gameLoop() {
      frameCount++;
      const now = Date.now();
      if (now - lastTime >= 1000) {
        fps = frameCount;
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastTime = now;
      }

      if (!paused) {
        gameTime += gameSpeed;
      }

      const hours = Math.floor(gameTime / 3600) % 24;
      const minutes = Math.floor((gameTime % 3600) / 60);
      document.getElementById('game-time').textContent = 
        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(255, 29, 108, 0.1)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      furniture.forEach(item => {
        drawSprite(item.sprite, item.x, item.y, '#666');
      });

      // Update agents
      agents.forEach(agent => {
        agent.update();
      });
      
      // Collision detection
      const agentArray = Array.from(agents.values());
      for (let i = 0; i < agentArray.length; i++) {
        for (let j = i + 1; j < agentArray.length; j++) {
          if (agentArray[i].checkCollision(agentArray[j])) {
            agentArray[i].resolveCollision(agentArray[j]);
          }
        }
      }
      
      // Draw agents
      agents.forEach(agent => {
        agent.draw();
      });

      if (selectedAgent && agents.has(selectedAgent.id)) {
        updateAgentPanel(selectedAgent);
      }

      document.getElementById('agent-count').textContent = agents.size;

      requestAnimationFrame(gameLoop);
    }

    for (let i = 0; i < 3; i++) {
      addAgent();
    }

    gameLoop();
    logEvent('Simulation v2 started! Now with personality, A*, collision, and memory!', 'action');
  </script>
</body>
</html>
